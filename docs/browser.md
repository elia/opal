Opal In The Browser
-------------------

Opals primary platform is the browser, and the runtime has a number of
components used to similate a ruby environment. To run ruby in the
browser, the best practice is to compile files ahead of time, into
javascript, which makes the runtime qucik and efficient. Opal offers an
external API to make it easy to register and load these compiled
libraries to make opal act like any other ruby runtime.

Overview of Opal API
====================

 Once opal.js is loaded in the browser, it exposes only one global
variable, `opal`. This namespace holds all the APIs needed to register
and load files.

### runtime

The `runtime` property of the opal variable is where all the core
runtime features of the ruby langaige are stored - this is what is
passed directly into each function to allow ruby code to access the opal
runtime to define classes, define methods, etc.

Most functions and properties of runtime should not be used directly as
they are purely aimed for use by code generated by the opal compiler.

### compile

The compile function on opal is a simple javascript function that will
compile a string of ruby code and return a string representation of the
javascript that can be run through opal. This function is only provided
once `opal-parser.js` is loaded, so just throws an error by default.
`opal-parser.js` should always be loaded after opal.js.

This function can be used simply from any browser debugger like:

```javascript
opal.compile("some ruby code");
// => "function() { ...js code... }"
```
### fs

The `fs` namespace holds various functions and properties that are used
to simulate a filesystem. Browsers do not have access to the local file
system, so opal simulates one which has no files (by default). Files can
be registered and added to this fake file system (see later), which
allows the usual ruby `File` and `Dir` classes to operate.

This namespace also supports a `cwd` property which stores the fake
current working directory of the application. This is useful for some
ruby libraries such as testing frameworks which rely on a current working
directory to find relevant test files.

Again, this is mostly used internally so should not need to be accessed
manually.

### require

The `require` function is a quick way to require a lib in opal. This
links directly with the ruby implementation to try and load a library at
the given path. If successfull, `true` is returned. If the lib has
already been loaded then `false` is returned as per ruby. If the lib
cannot be found then an error is thrown. These errors, while ruby
errors, are just regular javascript errors so can be caught and handled
easily.

To require a lib, it must be predefined. This is done with the methods
that follow which register them into the previously mentioned "fake"
file system. `require` simply locates the file in the fake file system
and then executes its body (which will be a function) and then just
returns a true or false result. No XHR or similar methods are used
during this process.

```javascript
opal.require("my_lib/builder");
// => true
opal.require("my_lib/builder");
// => false
opal.require("some_non_existant_lib");
// => thrown Exception
```

### cache

The cache property is simply used to store a list of libs already
loaded. When a lib is located, this cache is checked to make sure opal
is not trying to require the same file twice.

### lib

The lib function is used to register a compiled ruby file using the
given lib name and a given body. Constructing this call should not be
done manually as the opal build tools will do this with files you
compile. The lib name should be the name of the file as it should be
loaded with, i.e. it does not include a preceding path and it does not
contain the ruby file extension.

For example, to register the "my_lib/builder" file used above:

```javascript
opal.lib("my_lib/builder", function($rb, self, __FILE__) {
  // ruby code
});
```
This will register the lib file with a full path of
"/lib/my_lib/builder.rb" and that file will then exist in the fake file
system. All registered libs using this function will gain this preceding
"/lib" path.

### gem

For more complex file registering, the `gem` function is used. This is
the result of using `Opal::Bundle` which registers either a gem or a
similar app structure ready for opal. `Bundle` will compile a gem/app
with all of its lib files into an js object which is passed to this
function. The object will contain a `name` and `version` property which
are gathered from a gems' gemspec or its overriden properties (in a rake
task for instance).

An example for a made up library may look like the following:

```javascript
opal.gem({
  "name": "some_lib",
  "version": "0.0.1",
  "libs": {
    "some_lib": function() { /* implementation */ },
    "some_lib/foo": function() { /* implementation */ },
    "some_lib/bar": function() { /* implementation */ }
  }
});
```
The `libs` object contains a hash of all libs, which may be required,
and all their respective (compiled) ruby functions. Each of these files
is added to the fake file system using both their names, but also the
gem name is used to prefix them so that they dont clash with other gems.
The full file paths for these files will be:
"/some_lib/lib/some_lib.rb", "/some_lib/lib/some_lib/foo.rb", and "/some_lib/lib/some_lib/bar.rb" respectively.

Again, this function isnt really there to be used manually, but is used
from compiled gems to register themselves. It is also obvious that the
files must be defined before they can be required.

### loader

The `loader` property holds everything needed for resolving and loading
required files. It has a few important properties itself:

#### paths

This is an array of all the load paths. As gems are registered their
'lib' directories are added to this array. Also, the "/lib" directory is
also in this so that all single registered libs can be loaded directly.
This array is then exposed into ruby under the usual `$:` and
`$LOAD\_PATH` globals.

#### libs

This is a javascript object of all registered libs to their full paths.
These are libs registered with `lib` and with `gem`. The keys are the
lib names, i.e. the name used in `require()` which can be used to
require the file. These are stored here to make resolving much quicker
than going through all load paths. Once the full path is retrieved then
it is simply loaded (as below) and the implementation run. An example of
this object, based on the gem above, may look like:

```javascript
opal.loader.paths = {
  "some_lib": "/some_lib/lib/some_lib.rb",
  "some_lib/foo": "/some_lib/lib/some_lib/foo.rb",
  "some_lib/bar": "/some_lib/lib/some_lib/bar.rb"
};
```

#### factories

The `factories` property contains all registered files, not just
registered libs. It is a javascript object with all full paths as keys
and implmentations as values. These keys make up the faked file system,
so all ruby libraries like `File` and `Dir` use this object to simulate
a file system. The registered gem as above will result in factories
like:

```javascript
opal.loader.factories = {
  "/some_lib/lib/some_lib.rb": function() { /* implementation */ },
  "/some_lib/lib/some_lib/foo.rb": function() { /* implementation */ },
  "/some_lib/lib/some_lib/bar.rb": function() { /* implementation */ }
```

